# BOM Excel 업로드 로직 문서

**작성일**: 2025년 11월 28일  
**데이터베이스**: TAECHANG_ERP (Supabase PostgreSQL)  
**프로젝트 ID**: pybjnkbmtlyaftuiieyq

---

## 1. 현재 데이터베이스 상태

### 1.1 고객사별 BOM 통계

| 고객사명 | 고객사코드 | 모품목수 | 자품목수 | 총 BOM수 | 자기참조BOM | 활성BOM |
|---------|-----------|---------|---------|---------|-----------|---------|
| 대우당진 | CUS-DAEWOO-DJ | 4 | 5 | 8 | 7 | 4 |
| 대우포승 | CUS-DAEWOO-PS | 9 | 29 | 98 | 11 | 98 |
| 인알파코리아 | CUS-INALPA | 50 | 79 | 145 | 78 | 145 |
| 풍기서산 | CUS-PUNGGI-SS | 9 | 29 | 51 | 6 | 51 |
| 호원오토 | CUS-HOWON | 45 | 127 | 201 | 41 | 201 |

**전체 통계**:
- 총 모품목: 117개
- 총 자품목: 262개 (중복 제거)
- 총 BOM 관계: 503개
- 자기 참조 BOM: 183개
- 활성 BOM: 499개

### 1.2 BOM 테이블 구조

```sql
CREATE TABLE bom (
  bom_id SERIAL PRIMARY KEY,
  parent_item_id INTEGER NOT NULL REFERENCES items(item_id),
  child_item_id INTEGER NOT NULL REFERENCES items(item_id),
  quantity_required NUMERIC NOT NULL DEFAULT 1.0,
  level_no INTEGER NOT NULL DEFAULT 1,
  is_active BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
  labor_cost NUMERIC DEFAULT 0,
  machine_time NUMERIC DEFAULT 0,
  setup_time NUMERIC DEFAULT 0,
  notes TEXT,
  customer_id INTEGER REFERENCES companies(company_id),  -- 고객사별 분리
  child_supplier_id INTEGER REFERENCES companies(company_id)  -- 자품목 구매처
);
```

**주요 특징**:
- `customer_id`: 고객사별 BOM 분리 (대우당진, 대우포승 등)
- `child_supplier_id`: 자품목 구매처 정보
- `level_no`: BOM 레벨 (현재 모두 Level 1)
- `is_active`: 활성화 여부 (비활성화된 BOM 존재)

---

## 2. Excel 파일 구조

### 2.1 파일 형식

- **파일명**: `(추가)BOM 종합 - ERP (1).xlsx`
- **시트 구조**: 고객사별 시트 (대우당진, 대우포승, 풍기서산, 호원오토, 인알파코리아)
- **제외 시트**: `최신단가` (단가 정보만 포함)

### 2.2 시트 구조 (각 고객사별)

**헤더 행 (6번째 행, Excel 1-indexed = 6)**:
- A열: 납품처 (고객사명)
- B열: 차종
- C열: 품번
- D열: 품명
- E열: 단가
- F열: (빈 열)
- G열: (빈 열)
- H열: 업체구분 (구매처 카테고리)
- I열: 차종 (자품목)
- J열: 품번 (자품목)
- K열: 품명 (자품목)
- L열: U/S (소요량)
- M열: 단가 (자품목)

**데이터 행 (7번째 행부터)**:
- **모품목 행**: A-G열에 데이터가 있는 행 (납품처, 차종, 품번, 품명, 단가 등)
- **자품목 행**: A-G열이 비어있고, H열 이후에 데이터가 있는 행

### 2.3 Excel 파싱 로직

#### 2.3.1 파싱 알고리즘

```typescript
// 1. 모든 고객사 시트 순회 (최신단가 시트 제외)
for (시트명 in workbook.SheetNames) {
  if (시트명 === '최신단가') continue;
  
  // 2. 6번째 행에서 헤더 읽기
  const headers = readRow(worksheet, 5); // 0-indexed
  
  // 3. 7번째 행부터 데이터 읽기
  let currentParentRow = null;
  
  for (row = 6; row <= lastRow; row++) {
    // 4. 모품목 행 판단 (A-G열에 데이터 존재 여부)
    if (hasDataInColumns(row, A-G)) {
      currentParentRow = parseParentRow(row, headers);
      continue; // 모품목 행은 저장하지 않고 건너뛰기
    }
    
    // 5. 자품목 행 처리
    if (hasDataInColumns(row, H-M)) {
      const childData = parseChildRow(row, headers);
      
      // 6. BOM 관계 생성 (모품목 + 자품목)
      const bomEntry = {
        ...currentParentRow,
        ...childData,
        quantity_required: childData.U/S
      };
      
      // 7. 품번과 품명이 모두 다를 때만 BOM 엔트리로 추가
      if (isDifferentItem(parent, child)) {
        dataRows.push(bomEntry);
      }
    }
  }
}
```

#### 2.3.2 주요 파싱 규칙

1. **모품목 판단**:
   - A-G열 중 하나라도 데이터가 있으면 모품목 행
   - 모품목 행의 정보는 `currentParentRow`에 저장

2. **자품목 판단**:
   - A-G열이 모두 비어있고, H열 이후에 데이터가 있으면 자품목 행
   - 바로 앞 모품목 행의 정보와 병합

3. **BOM 관계 생성 조건**:
   - 품번(`item_code`)이 다름
   - 품명(`item_name`)이 다름
   - 소요량(`quantity_required`)이 0보다 큼

4. **자기 참조 처리**:
   - 품번과 품명이 같은 경우에도 BOM 관계 생성 (자기 참조)
   - 단, 구매처가 다른 경우 별도 BOM 엔트리로 처리

---

## 3. 데이터베이스 저장 로직

### 3.1 API 엔드포인트

**엔드포인트**: `POST /api/bom/upload`

**요청 형식**:
```typescript
FormData {
  file: File  // Excel 파일
}
```

**응답 형식**:
```typescript
{
  success: boolean;
  message: string;
  data: {
    insertedRecords: number;
    errors: ValidationError[];
    stats: {
      total_rows: number;
      valid_rows: number;
      error_rows: number;
    };
  };
}
```

### 3.2 저장 프로세스

#### Step 1: Excel 파싱
```typescript
const validationResult = parseBOMExcel(buffer);
// 반환값: { valid, data, errors, stats }
```

#### Step 2: 고객사 식별
```typescript
// 시트명 또는 납품처명으로 고객사 ID 조회
const customer = await findCustomerBySheetName(sheetName);
// 또는
const customer = await findCustomerByName(parent_supplier);
```

#### Step 3: Items 업서트/조회
```typescript
// 모품목 처리
const parentItem = await upsertItem({
  item_code: parent_item_code,
  item_name: parent_item_name,
  car_model: parent_car_model,
  unit_price: parent_unit_price,
  // ...
});

// 자품목 처리
const childItem = await upsertItem({
  item_code: child_item_code,
  item_name: child_item_name,
  car_model: child_car_model,
  unit_price: child_unit_price,
  // ...
});
```

#### Step 4: 구매처(Companies) 업서트/조회
```typescript
// 자품목 구매처 처리
const supplier = await upsertCompany({
  company_name: child_supplier_name,
  company_type: '협력업체', // 또는 '사급', '하드웨어' 등
  company_category: child_supplier_category,
  // ...
});
```

#### Step 5: BOM 관계 저장
```typescript
// 기존 BOM 확인 (customer_id, parent_item_id, child_item_id 조합)
const existingBom = await findBom({
  customer_id: customer.company_id,
  parent_item_id: parentItem.item_id,
  child_item_id: childItem.item_id
});

if (existingBom) {
  // 업데이트
  await updateBom(existingBom.bom_id, {
    quantity_required: quantity_required,
    child_supplier_id: supplier.company_id,
    is_active: true,
    updated_at: NOW()
  });
} else {
  // 신규 생성
  await insertBom({
    customer_id: customer.company_id,
    parent_item_id: parentItem.item_id,
    child_item_id: childItem.item_id,
    quantity_required: quantity_required,
    level_no: 1,
    child_supplier_id: supplier.company_id,
    is_active: true
  });
}
```

### 3.3 데이터 검증

#### 3.3.1 필수 필드 검증
- 모품목: `품번`, `품명` (또는 `item_code`, `item_name`)
- 자품목: `품번`, `품명`, `소요량` (또는 `U/S`)

#### 3.3.2 순환 참조 검증
```typescript
// BOM 저장 전 순환 참조 확인
const hasCycle = await checkBomCircular(
  parent_item_id,
  child_item_id,
  customer_id
);

if (hasCycle) {
  throw new Error('순환 참조가 감지되었습니다.');
}
```

#### 3.3.3 중복 검증
- 동일한 `customer_id`, `parent_item_id`, `child_item_id` 조합은 하나만 존재
- 중복 시 기존 레코드 업데이트 (UPSERT)

---

## 4. 주요 로직 특징

### 4.1 고객사별 BOM 분리

**목적**: 각 고객사(대우당진, 대우포승 등)의 BOM이 서로 섞이지 않도록 분리

**구현**:
- `bom` 테이블에 `customer_id` 컬럼 추가
- 고객사별 BOM 조회 시 `WHERE customer_id = ?` 필터 적용
- 고유 제약조건: `UNIQUE (customer_id, parent_item_id, child_item_id)`

**예시**:
```sql
-- 대우당진의 BOM만 조회
SELECT * FROM bom
WHERE customer_id = (SELECT company_id FROM companies WHERE company_code = 'CUS-DAEWOO-DJ');
```

### 4.2 자기 참조 BOM

**현황**: 전체 BOM 중 183개(36%)가 자기 참조

**용도**:
- 동일 품목이 다른 구매처에서 구매되는 경우
- 예: `65852-BY000` (대우당진) ← `65852-BY000` (태창금속)

**처리 방식**:
- 품번과 품명이 같더라도 BOM 관계 생성
- `child_supplier_id`로 구매처 구분

### 4.3 구매처(Supplier) 관리

**자품목 구매처 정보**:
- `child_supplier_id`: `companies` 테이블 참조
- 구매처 카테고리: 협력업체, 사급, 하드웨어, 태창금속 등

**처리 로직**:
1. Excel에서 구매처명 또는 업체구분 읽기
2. `companies` 테이블에서 조회 (이름 또는 코드로)
3. 없으면 신규 생성
4. BOM 저장 시 `child_supplier_id` 설정

### 4.4 비활성화된 BOM

**현황**: 일부 BOM이 `is_active = false`로 저장됨

**처리 방식**:
- 기존 BOM이 비활성화된 경우, 새로 업로드 시 활성화
- 사용자가 수동으로 비활성화한 BOM은 유지
- UI에서는 활성화된 BOM만 표시 (기본값)

---

## 5. 데이터 흐름도

```
Excel 파일 업로드
    ↓
[1] Excel 파싱
    ├─ 시트별 처리
    ├─ 헤더 읽기 (6번째 행)
    ├─ 모품목/자품목 구분
    └─ BOM 관계 추출
    ↓
[2] 데이터 검증
    ├─ 필수 필드 확인
    ├─ 순환 참조 검사
    └─ 중복 확인
    ↓
[3] 고객사 식별
    ├─ 시트명 또는 납품처명으로 고객사 조회
    └─ customer_id 설정
    ↓
[4] Items 업서트
    ├─ 모품목 업서트/조회
    ├─ 자품목 업서트/조회
    └─ item_id 획득
    ↓
[5] Companies 업서트
    ├─ 구매처 업서트/조회
    └─ company_id (supplier) 획득
    ↓
[6] BOM 저장
    ├─ 기존 BOM 확인
    ├─ UPSERT (업데이트 또는 삽입)
    └─ customer_id, child_supplier_id 설정
    ↓
[7] 응답 반환
    ├─ 저장된 레코드 수
    ├─ 오류 목록
    └─ 통계 정보
```

---

## 6. 에러 처리

### 6.1 검증 오류

**필수 필드 누락**:
```typescript
{
  row: 10,
  field: 'parent_item_code',
  message: '모품목 품번이 없습니다.'
}
```

**순환 참조**:
```typescript
{
  row: 20,
  field: 'circular_dependency',
  message: '순환 참조가 감지되었습니다: A → B → C → A'
}
```

### 6.2 데이터베이스 오류

**고객사 없음**:
```typescript
{
  message: '고객사를 찾을 수 없습니다: 대우당진'
}
```

**Items 중복**:
- 동일한 `item_code`가 이미 존재하는 경우 업데이트
- 차종이 다른 경우 별도 품목으로 처리 (품번 + 차종 조합)

---

## 7. 현재 구현 상태

### 7.1 완료된 기능

✅ Excel 파일 파싱 (고객사별 시트 지원)  
✅ 모품목/자품목 구분 로직  
✅ 고객사별 BOM 분리  
✅ 자기 참조 BOM 지원  
✅ 구매처(Supplier) 관리  
✅ 순환 참조 검증  
✅ UPSERT 로직 (중복 시 업데이트)  
✅ 비활성화된 BOM 처리  

### 7.2 개선 가능한 영역

⚠️ **다단계 BOM**: 현재 모든 BOM이 Level 1. 다단계 BOM 지원 필요 시 개선  
⚠️ **실시간 검증**: 업로드 전 Excel 파일 구조 검증 강화  
⚠️ **에러 복구**: 부분 실패 시 롤백 또는 재시도 로직  
⚠️ **성능 최적화**: 대량 데이터 업로드 시 배치 처리  

---

## 8. 사용 예시

### 8.1 Excel 파일 업로드 (API)

```bash
curl -X POST http://localhost:5000/api/bom/upload \
  -F "file=@BOM_종합.xlsx"
```

### 8.2 응답 예시

```json
{
  "success": true,
  "message": "BOM 데이터가 성공적으로 업로드되었습니다.",
  "data": {
    "insertedRecords": 503,
    "errors": [],
    "stats": {
      "total_rows": 520,
      "valid_rows": 503,
      "error_rows": 17
    }
  }
}
```

---

## 9. 참고 사항

### 9.1 관련 파일

- **API 엔드포인트**: `src/app/api/bom/upload/route.ts`
- **Excel 파서**: `src/lib/excel-bom-parser.ts`
- **헤더 매퍼**: `src/lib/excel-header-mapper.ts`
- **BOM 유틸리티**: `src/lib/bom.ts`

### 9.2 데이터베이스 마이그레이션

- `add_customer_id_to_bom`: 고객사별 BOM 분리
- `update_bom_unique_constraint_with_customer`: 고유 제약조건 업데이트

---

**문서 버전**: 1.0  
**최종 업데이트**: 2025-11-28  
**작성자**: 시스템 분석

